# spring-boot-lecture

●영속성 컨텍스트
- 엔티티를 영구 저장하는 환경이라는 뜻
- 어플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의 데이터베이스를 의미한다.
- 엔티티 매니저를 사용하여 영속성 컨텍스트에 접근하고 관리하는 것
- em.persist(member)을 활용해 member객체를 영속성 컨텍스트에 저장하는 것
- 엔티티 매니저를 사용하는 모든 데이터 변경은 항상 트랜잭션안에서 되야하므로 꼭 @Transactional을 붙여줘야한다

●Embedded 
- Entity를 깔끔하게 표현하기위해서 사용하는 어노테이션 
- 여러개의 값이 있지만 결국 하나의 값을 나타낼 때 사용한다.
- 주로 주소에 많이 사용된다. (우편번호 + 도로명주소 같은 느낌?)

●연관 관계 설정시 
1. EAGER : 즉시로딩으로 실행될 때 연관된 모든 연관관계를 다 끌고 오기 때문에 어떤 sql이 실행될지 추적하기 어렵다
2. LAZY : 지연로딩으로 필요할 때만 연관 관계를 가져오는 방식으로 실무에선 꼭 이것을 사용해야한다고 한다

● @Transactional : 데이터베이스의 상태를 변경하는 작업 또는 데이터베이스를 기반으로 수행되어야 하는 연산들을 의미하는 어노테이션
findmember같이 데이터베이스를 읽기만 하는 것에는 readOnly = true를 붙여줘서 좀 더 연산이 빠르게 될 수 있게 하고 회원가입같이 새로 생성하는 로직같은 경우는 붙이면 안된다

● @RequiredArgsConstructor : 초기화 되지않은 final 필드에 대해 생성자를 생성해준다.
만약 memberRepository를 service에 의존성 주입시에 @Autowired를 사용하여 주입하면 변경이 불가능하기 때문에 테스트를 수행하기 굉장히 까다롭다 그렇기 때문에 따로 생성자를 만들어서 해당하는 repository를 넣어주는 식으로 행하는 것이 좋은데 그것을 따로 생성하지않아도 자동으로 생성해주는 것이 이 어노테이션이다  

●준영속 엔티티
1. 영속성 컨텍스트가 더는 관리하지 않는 엔티티를 의미한다.
2. 데이터베이스에 정확하게 다녀온 객체를 준영속 상태의 객체라고 한다. 내용물을 수정할 때 발생하는 상황
3. 준영속 엔티티는 기본적으로 JPA가 관리하지않는다.
4. 준영속 엔티티를 수정하는 방법은 2가지가있다.

첫 번째 : 변경감지 -> repository에서 id를 기반으로 해당하는 아이템을 찾아낸다면 그것은 영속되어있는 아이템을 찾아온 것이다. 그 찾은 쿼리에서 set방식을 사용하게 된다면 그 해당하는 영속된 아이템의 상태를 변경하게 된다.
@Transactional
void update(Item itemParam) { //itemParam: 파리미터로 넘어온 준영속 상태의 엔티티
 Item findItem = em.find(Item.class, itemParam.getId()); //같은 엔티티를 조회한
다.
 findItem.setPrice(itemParam.getPrice()); //데이터를 수정한다.
}

두 번째 : merge(병합) 사용 -> JPA가 id를 기반으로 해당하는 item을 찾아서 해당값들을 모두 바꿔치기 한다. 파라미터로 넘어온 준영속 엔티티의 식별자 값으로 조회하여 그 해당 객체에 준영속 엔티티에서 가져온 데이터들을 모두 밀어넣어 바꿔치기를 한다.

주의 : 변경감지기능을 사용하면 원하는 부분만을 설정하여 변경할 수 있지만 merge를 사용하면 파라미터로 받아온 모든 것들을 바꿔버리기 때문에 값이 null이여도 싹다 넣어버리기 때문에 사용시 주의해야한다. 변경감지 >> merge

REST란?
HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미한다.
JSON 혹은 XML를 통해 데이터를 주고 받는 것이 일반적이다.

API란?
데이터와 기능의 집합을 제공하여 컴퓨터 프로그램간 상호작용을 촉진하며, 서로 정보를 교환가능 하도록 하는 것

REST API란?
REST기반으로 API를 구현하는 것이다.


@RestController : @Controller + @ResposeBody
1. Json 형태로 객체 데이터를 반환하기위해 사용한다.
2. Restful Api를 개발하기 위해 사용된다.

●API를 만들 때는 Entity를 외부에 노출하거나 Param으로 받아서 사용하면 안된다.
API는 요청이 들어올때나 나갈때나 엔티티를 사용하는게 아니라 DTO객체를 따로 만들어서 사용하는 것이 좋다. 엔티티를 노출하게 되면 나는 회원정보만 알고싶어서 member를 조회했는데 member엔티티에 들어있는 모든 내용이 싹다 노출되게 된다.

만약 엔티티를 직접 노출하는데 내용을 내보내고 싶지않다면 엔티티에 @JsonIgnore을 붙이면 된다. 그러면 API를 사용해 조회할 때 노출되지않는다.
하지만 결국 언제는 있어야하고 언제는 없어야 할 시기가 있는데 유동적으로 대응할 수가 없다.


--------------------------
1. 엔티티를 직접 노출하기 : 무한루프에 빠질수있으며 굉장히 번거롭고 힘듬
2. 엔티티를 DTO로 변환 : 쿼리가 연관관계에 있는 엔티티들을 계속 새로 조회하기 때문에 성능부분에서 좀 떨어진다.
3. 패치조인으로 조회 : 연관관계가 맺어진 엔티티들을 패치조인으로 명시하여 조인을 한번에 실행하기 때문에 쿼리가 지속해서 생성되는 것이 아니라 한번에 다가져온다. 단순하게 DTO로 변환하는것보다 성능에 우위가있다.


-----------------------------------------------------------------------------
기능목록 
1. 회원 기능 : 회원 등록 + 회원 조회
2. 상품 기능 : 상품 등록 + 상품 수정 + 상품 조회
3. 주문 기능 : 상품 주문 + 주문 내역 조회 + 주문 취소
4. 기타 요구사항 
	1) 상품은 제고 관리가 필요(주문하면 남은 개수가 줄어드는 것, 취소하면 다시 올라	   가고)
	2) 상품의 종류는 도서, 음반, 영화가 있다.
	3) 상품은 카테고리 별로 구분할 수 있어야 한다.
	4) 상품 주문 시 배송 정보를 입력할 수 있다.

연관관계
1. 회원과 주문 : 일대다, 다대일의 양방향 관계로서 왜래 키가 있는 주문을 연관관계의 주인으로 정하는 것이 좋다.
2. 주문상품과 주문 : 다대일 양방향 관계이다. 왜래 키가 주문상품에 있으므로 주문상품이 연관관계의 주인이다.
3. 주문상품과 상품 : 다대일 단방향 관계이다. 하나의 상품은 여러 주문상품에 포함될 수 있다. 즉, 하나의 상품이 a의 주문 상품 목록에도 있고 b의 주문상품 목록에도 있을 수 있다는 말

![image01](https://user-images.githubusercontent.com/90305145/154275460-73e2e6c1-b3f7-446e-91e7-830d31d12d28.png)

![image02](https://user-images.githubusercontent.com/90305145/154275615-96eb09ef-5fb6-4a6f-bba6-15d8c2c341d4.png)
